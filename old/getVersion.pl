#! /usr/bin/perl 
#  Script for generation of version info suitable for application use
#  This is a much simplified version that takes the latest commit for files in a given directory
#  The version string generated is of the form
#  [branch-]yyyy.mm.dd.(release | sha1)[+][?]
#     yyyy.mm.dd  is the date in UTC of the last commit, leading zeros omitted
#     release     is the numeric component of the release tag if the commit has a tag associated
#     sha1        is the start of the git SHA1
#     +           added if uncommitted files
#     ?           added if no git, the question mark represents untracked
#     branch      present if not non main or master. A detached branch is shown as (detached)
#  if git information cannot be found and an output file is specified then
#     if the output file already exists the existing version in it is used with a ? appended unless it has one already
#     else the version string is set to xxxx.xx.xx.xx ?
#
#  To support different programming languages, an optional version.in file can be supplied with the following contents
#
#  [versionfileName]     // [] are required but the whole line can be omitted. default is _version.h
#  template 
#
#  Where template is any text but the string @V@ is replaced with the generated git version string
#  and @D@ is replaced by today's date in the format YYYY-MM-DD HH:MM:SS
#
#  Note, to allow the version string to be read by this script, one line should contain the case insensitive
#  string GIT_VERSION and the the @V@ token
#  examples
#     C    -> #define GIT_VERSION "@V@"
#     PL/M -> declare version(*) BYTE data('@V@'); /* git_version */
# 
#  if version.in is not present the output file is _version.h and the default template is
#  // Autogenerated version file
#  #define GIT_VERSION    "@V@"
#
#  Unless surpressed by the -q flag, the generated version is shown on the console
#  -w writes a new output file only if the version has changed or the output file is missing
#  -W write a new output file
#  -f is an alias for -W to align with powershell implementation
#
#  Note when commits are made, without using the Publish-Release command script then the commited output file
#  will contain the most recent version prior to the commit. If copied to an environment
#  without git installed this version will not be auto corrected, although a ? will be appended
#  It is recommended for sharing the Publish-Release command is used. This will create a git commit and a
#  tag of the form dirname-rnnn. Before committing it will also generate a corresponding version string
#  with the release component set to nnn.
#  Note nnn is a decimal number without leading zeros.
use Cwd;
use POSIX 'ctime';
use File::Basename;
my $VER_FILE;
my $fQUIET;
my $fSIMPLE;
my $WMODE = 0;  # 0 - no write, 1 - write if changed, 2 - always write
my @TEMPLATE = ("// Autogenerated version file\r\n", "#define GIT_VERSION     \"\@V\@\"\r\n");
my $OLD_GIT_VERSION;
my $GIT_CHKDATE = POSIX::strftime("%Y-%m-%d %H:%M:%S", gmtime);
my $DEF_VER_FILE="_version.h";
my $CFG_FILE="version.in";

my $cwd = cwd();
$cwd =~ s/.*\///;   # parent directory name

sub usage {
    my $invokeName = basename($0);
    print <<EOF;
usage: $invokeName -v | [-h] | [-q] [-s] [-w|-W|-f] [-c file] 

 When called without arguments version information writes to console

 -v          - displays script version information
 -h          - displays this usage information

 -q          - Suppress console output, ignored if not writing to file
 -s          - simplified console output version. No warning messages
 -w          - write file if version changed
 -W          - write file even if version unchanged
 -f          - alias for -W
 -c file     - set the config file

 The default generated file is $DEF_VER_FILE as a C/C++ header file
 An optional $CFG_FILE can be used to override these, see documentation
EOF
    exit(0);
}

sub getConfig {
    if (open my $in, "<:raw", $CFG_FILE) {
        my @template = <$in>;
        close $in;
        shift @template while ($template[0] ne "" && $template[0] =~ /^\s*$/);
        if ($template[0] =~ /^\[([^\]]+)]/) {
            $VER_FILE = $1;
            $VER_FILE =~ s/\\/\//g;
            shift @template;
        }
        shift @template while ($template[0] ne "" && $template[0] =~ /^\s*$/);
        @TEMPLATE = @template if $#template >= 0;
    }
    $VER_FILE = $DEF_VER_FILE if $VER_FILE eq "";
}


# getOpts, return 1 if ok to proceeed
sub getOpts {
    while (my $opt = shift @ARGV) {
        if (lc($opt) eq "-v") {    
            print basename($0), ": Ver _REVISION_\n";
            exit(0);
        }
        if (lc($opt) eq "-q") {
            $fQUIET = 1;
        } elsif (lc($opt) eq "-s") {
            $fSIMPLE = 1;
        } elsif ($opt eq "-w" && $WMODE == 0) {
            $WMODE = 1;
        } elsif (($opt eq "-W" || $opt eq "-f") && $WMODE == 0) {
            $WMODE = 2;
        } elsif (lc($opt) eq "-c" && $#ARGV >= 0) {
            $CFG_FILE = shift @ARGV;
        } else {
            usage();
        }
    }
    $fQUIET = 0 if $WMODE == 0;
} 



sub time2Ver {
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime($_[0]);
    $year += 1900;
    $mon++;
    return "$year.$mon.$mday";

}

sub getOldVersion {
   if (-f $VER_FILE && open my $fh, "<", $VER_FILE) {
        while (<$fh>) {
            if (/GIT_VERSION/i && /((\[detached\]-|\w[-_\w\/\.]*-)?20\d\d\.\d{1,2}\.\d{1,2}\.\w+\+?\??)/) {
                $OLD_GIT_VERSION = $1;
                last;
            }
        } 
        close $fh;
   }
   if ($OLD_GIT_VERSION eq "") {
      $WMODE = 2 if $WMODE == 1;
      $OLD_GIT_VERSION="xxxx.xx.xx.xx?";
   }
}

sub getVersionString {
# check for banch and any outstanding commits in current tree
    if (open my $in, "git branch --show-current 2>&1 | ") {
        $branch = <$in>;
        chomp $branch;
        close $in;
        if ($banch =~ /&^fatal:/) {
            print "Not in a Git repository\n";
        } else {
            # get the current SHA1 and commit time and any tag for the current directory
            open my $in, "git log -1 --decorate-refs=\"tags/$cwd-r*\" --format=\"%h,%ct,%D\" -- . |" or die $!;
            ($GIT_SHA1, $GIT_CTIME, $TAG) = split /,/,<$in>, 3;
            close $in;
            if ($GIT_CTIME ne "") {
                if ($branch eq "") {
                    $GIT_VERSION = "[detached]-";
                } elsif ($branch ne "main" && $branch ne "master") {
                    $GIT_VERSION = "$branch-";
                } else {
                    $GIT_VERSION = "";
                }
                $GIT_VERSION .= time2Ver($GIT_CTIME);
                $GIT_SHA1 = $1 if ($TAG =~ /(\d+)\r?$/);
                $GIT_VERSION .= ".$GIT_SHA1";
                $GIT_VERSION .= "+" if system("git diff-index --quiet HEAD -- .");
            } else {
                print "$cwd is not in the repository\n";
            }
        }
        close $in;
    }
}


sub writeOut {
    return if $WMODE == 1 && -f $VER_FILE && $OLD_GIT_VERSION eq $GIT_VERSION;
    open my $out, ">:raw", $VER_FILE or die "can't write $VER_FILE";
    for my $line (@TEMPLATE) {
        $line =~ s/\@V\@/$GIT_VERSION/ig;
        $line =~ s/\@D\@/$GIT_CHKDATE/ig;
        print $out $line;
    }
    close $out;
}


main:   # main code
getOpts();
getConfig();
getOldVersion();
getVersionString();
if ($GIT_VERSION eq "") {
    print "No Git information found\n" unless $fSIMPLE;
    $GIT_VERSION = $OLD_GIT_VERSION;
    $GIT_VERSION .= "?" unless substr($GIT_VERSION, -1) eq "?";
}

writeOut() if $WMODE != 0;
print "$cwd - " unless $fQUIET || $fSIMPLE;
print "$GIT_VERSION\n" if !$fQUIET;
